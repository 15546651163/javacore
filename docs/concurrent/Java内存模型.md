---
ngtitle: Java 内存模型
date: 2018/05/19
categories:
- javase
tags:
- javase
- concurrent
---

# Java 内存模型

> 本文内容基于 JDK1.8。
>
> Java 内存模型（Java Memory Model），以下简称 JMM。

<!-- TOC depthFrom:2 depthTo:3 -->

- [简介](#简介)
- [资料](#资料)

<!-- /TOC -->

## 简介

JVM 中试图定义一种 JMM 来屏蔽各种硬件和操作系统的内存访问差异，以实现让 Java 程序在各种平台下都能达到一致的内存访问效果。

JMM 的主要目标是定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。此处的变量与 Java 编程中的变量有所区别，它包括了实例字段、静态字段和构成数组对象的元素，但不包括局部变量与方法参数，因为后者是线程私有的，不会被共享，自然就不会存在竞争问题。为了获得较好的执行效能，Java 内存模型并没有限制执行引擎使用处理器的特定寄存器或缓存来和主存进行交互，也没有限制即使编译器进行调整代码执行顺序这类优化措施。

重排序 - JMM 使得不同线程看到的操作执行顺序是不同的。

JMM 是通过各种操作来定义的，包括对变量的读写操作，监视器的加锁和释放操作，以及线程的启动和合并操作。

JMM 为程序中所有的操作定义了一个偏序关系，称之为 Happens-Before。

* **程序顺序规则**：如果程序中操作 A 在操作 B 之前，那么在线程中操作 A 将在操作 B 之前执行。
* **监视器锁规则**：在监视器锁上的解锁操作必须在同一个监视器锁上的加锁操作之前执行。
* **volatile 变量规则**：对 volatile 变量的写入操作必须在对该变量的读操作之前执行。
* **线程启动规则**：在线程上对 Thread.start 的调用必须在该线程中执行任何操作之前执行。
* **线程结束规则**：线程中的任何操作都必须在其他线程检测到该线程已经结束之前执行，或者从 Thread.join 中成功返回，或者在调用 Thread.isAlive 时返回 false。
* **中断规则**：当一个线程在另一个线程上调用 interrupt 时，必须在被中断线程检测到 interrupt 调用之前执行（通过抛出 InterruptException，或者调用 isInterrupted 和 interrupted）。
* **终结器规则**：对象的构造函数必须在启动该对象的终结器之前执行完成。
* **传递性**：如果操作 A 在操作 B 之前执行，并且操作 B 在操作 C 之前执行，那么操作 A 必须在操作 C 之前执行。

JMM 是围绕着在并发过程中如何处理原子性、可见性和有序性这 3 个特征来建立的。

## 资料

* [Java 并发编程实战](https://item.jd.com/10922250.html)：第 16 章 Java 内存模型
* [Java 并发编程的艺术](https://item.jd.com/11740734.html)：第 12 章 Java 内存模型与线程
* [深入理解 Java 虚拟机](https://item.jd.com/11252778.html)
* http://tutorials.jenkov.com/java-concurrency/java-memory-model.html
