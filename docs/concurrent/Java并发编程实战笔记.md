# Java 并发编程实战笔记

<!-- TOC depthFrom:2 depthTo:3 -->

- [第 1 章 简介](#第-1-章-简介)
  - [1.1 并发简史](#11-并发简史)
  - [1.2 线程的优势](#12-线程的优势)
  - [1.3 线程带来的风险](#13-线程带来的风险)
  - [1.4 线程无处不在](#14-线程无处不在)
- [第 2 章 线程安全性](#第-2-章-线程安全性)
  - [2.1 什么是线程安全性](#21-什么是线程安全性)
  - [2.2 原子性](#22-原子性)
  - [2.3 加锁机制](#23-加锁机制)
  - [2.4 用锁来保护状态](#24-用锁来保护状态)
  - [2.5 活跃性与性能](#25-活跃性与性能)
- [第 3 章 对象的共享](#第-3-章-对象的共享)
  - [3.1 可见性](#31-可见性)
  - [3.2 发布与逸出](#32-发布与逸出)
  - [3.3 线程封闭](#33-线程封闭)
  - [3.4 不变性](#34-不变性)
  - [3.5 安全发布](#35-安全发布)
- [第 4 章 对象的组合](#第-4-章-对象的组合)
  - [4.1 设计线程安全的类](#41-设计线程安全的类)
  - [4.2 实例封闭](#42-实例封闭)
  - [4.3 线程安全性的委托](#43-线程安全性的委托)
  - [4.4 在现有的线程安全类中添加功能](#44-在现有的线程安全类中添加功能)
  - [4.5 将同步策略文档化](#45-将同步策略文档化)
- [第 5 章 基础构建模块](#第-5-章-基础构建模块)
  - [5.1 同步容器类](#51-同步容器类)
  - [5.2 并发容器](#52-并发容器)
  - [5.3 BlockingQueue](#53-blockingqueue)
  - [5.4 阻塞方法与中断方法](#54-阻塞方法与中断方法)
  - [5.5 同步工具类](#55-同步工具类)
  - [5.6 构建高效且可伸缩的结果缓存](#56-构建高效且可伸缩的结果缓存)
- [第 6 章 任务执行](#第-6-章-任务执行)
  - [6.1 在线程中执行任务](#61-在线程中执行任务)
  - [6.2 Executor 框架](#62-executor-框架)
  - [6.3 找出可利用的并行性](#63-找出可利用的并行性)
- [第 7 章 取消与关闭](#第-7-章-取消与关闭)
  - [7.1 任务取消](#71-任务取消)
  - [7.2 停止基于线程的服务](#72-停止基于线程的服务)
  - [7.3 处理非正常的线程终止](#73-处理非正常的线程终止)
  - [7.4 JVM 关闭](#74-jvm-关闭)
- [第 8 章 线程池的使用](#第-8-章-线程池的使用)
  - [8.1 在任务与执行策略之间的隐性耦合](#81-在任务与执行策略之间的隐性耦合)
  - [8.2 设置线程池的大小](#82-设置线程池的大小)
  - [8.3 配置 ThreadPoolExecutor](#83-配置-threadpoolexecutor)
  - [8.4 扩展 ThreadPoolExecutor](#84-扩展-threadpoolexecutor)
  - [8.5 递归算法的并行化](#85-递归算法的并行化)
- [第 9 章 图形用户界面应用程序](#第-9-章-图形用户界面应用程序)
- [第 10 章 避免活跃性危险](#第-10-章-避免活跃性危险)
  - [10.1 死锁](#101-死锁)
  - [10.2 死锁的避免与诊断](#102-死锁的避免与诊断)
  - [10.3 其他活跃性危险](#103-其他活跃性危险)
- [第 11 章 性能与可伸缩性](#第-11-章-性能与可伸缩性)
  - [11.1 对性能的思考](#111-对性能的思考)
  - [11.2 Amdahl 定律](#112-amdahl-定律)
  - [11.3 线程引入的开销](#113-线程引入的开销)
  - [11.4 减少锁的竞争](#114-减少锁的竞争)
  - [11.5 示例：比较 Map 的性能](#115-示例比较-map-的性能)
  - [11.6 减少上下文切换的开销](#116-减少上下文切换的开销)
- [第 12 章 并发程序的测试](#第-12-章-并发程序的测试)
  - [12.1 正确性测试](#121-正确性测试)
  - [12.2 性能测试](#122-性能测试)
  - [12.3 避免性能测试的陷阱](#123-避免性能测试的陷阱)
  - [12.4 其他的测试方法](#124-其他的测试方法)
- [第 13 章 显式锁](#第-13-章-显式锁)
  - [13.1 Lock 与 ReentrantLock](#131-lock-与-reentrantlock)
  - [13.2 性能考虑因素](#132-性能考虑因素)
  - [13.3 公平性](#133-公平性)
  - [13.4 在 synchronized 和 ReentrantLock 之间进行选择](#134-在-synchronized-和-reentrantlock-之间进行选择)
  - [13.5 读-写锁](#135-读-写锁)
- [第 14 章 构建自定义的同步工具](#第-14-章-构建自定义的同步工具)
  - [14.1 状态依赖性的管理](#141-状态依赖性的管理)
  - [14.2 使用条件队列](#142-使用条件队列)
  - [14.3 显式的 Condition 对象](#143-显式的-condition-对象)
  - [14.4 Synchronizer 剖析](#144-synchronizer-剖析)
  - [14.5 AbstractQueuedSynchronizer](#145-abstractqueuedsynchronizer)
  - [14.6 java.util.concurrent 同步器类中的 AQS](#146-javautilconcurrent-同步器类中的-aqs)
- [第 15 章 原子变量与非阻塞同步机制](#第-15-章-原子变量与非阻塞同步机制)
  - [15.1 锁的劣势](#151-锁的劣势)
  - [15.2 硬件对并发的支持](#152-硬件对并发的支持)
  - [15.3 原子变量类](#153-原子变量类)
  - [15.4 非阻塞算法](#154-非阻塞算法)
- [第 16 章 Java 内存模型](#第-16-章-java-内存模型)
  - [16.1 什么是内存模型，为什么需要它](#161-什么是内存模型为什么需要它)
  - [16.2 发布](#162-发布)
  - [16.3 初始化过程中的安全性](#163-初始化过程中的安全性)

<!-- /TOC -->

## 第 1 章 简介

### 1.1 并发简史

### 1.2 线程的优势

* 1.2.1 发挥多处理器的强大能力
* 1.2.2 建模的简单性
* 1.2.3 异步事件的简化处理
* 1.2.4 响应更灵敏的用户界面

### 1.3 线程带来的风险

* 1.3.1 安全性问题
* 1.3.2 活跃性问题
* 1.3.3 性能问题

### 1.4 线程无处不在

# 第一部分 基础知识

## 第 2 章 线程安全性

线程安全的代码，其核心在于要对状态访问操作进行管理，特别是对共享的和可变的状态的访问。对象的状态是指存储在状态变量中的数据。对象的状态可能包括其他依赖对象的域。共享意味着变量可由多个线程同时访问，而可变意味着变量的值在其生命周期内可以发生变化。要使得对象是线程安全的，需要同步机制来协同对对象可变状态的访问。

### 2.1 什么是线程安全性

当多个线程访问某各类时，不管运行时环境采用何种调度方式或者这些线程将如何交替执行，并且在主调代码中不需要任何额外的同步或协同，这个类始终都能表现出正确的行为，那么就称这个类是线程安全的。

无状态对象一定是线程安全的。

### 2.2 原子性

* 竞态条件（Race Condition）：由于不恰当的执行时序而出现不正确的结果。
  * 大多数竞态条件的本质：基于一种可能失效的观察结果来做出判断或者执行某个计算。这种类型的竞态条件称为先检查后执行。

### 2.3 加锁机制

要保证状态的一致性，就需要在单个原子操作中更新所有相关的状态变量。

Java 提供了一种内置的锁机制来支持原子性：synchronized。

每个 Java 对象都可以用作一个实现同步的锁，这些锁被称为内置锁或监视锁。线程在进入同步代码块之前会自动获得锁，并且在退出同步代码块时会自动释放锁。

某个线程请求一个由其他线程持有的锁时，发出请求的线程就会阻塞。然而，由于内置锁是可重入的，因此如果某个线程试图获得一个已经由它自己持有的锁，那么这个请求就会成功。

### 2.4 用锁来保护状态

每个共享的和可变的变量都应该只由一个锁来保护。

对于每个包含多个变量的不变性条件，其中涉及的所有变量都需要由同一个锁来保护。

并非所有数据都需要锁的保护，只有被多个线程同时访问的可变数据才需要通过锁来保护。

虽然 synchronized 方法可以确保单个操作的原子性，但如果要把多个操作合并为一个复合操作，还是需要额外的加锁机制。

### 2.5 活跃性与性能

不要盲目地为了性能而牺牲简单性。

当执行时间较长的计算或可能无法快速完成的操作时（如，网络 I/O 或控制台 I/O），一定不要持有锁。

## 第 3 章 对象的共享

### 3.1 可见性

* 在没有同步的情况下，编译器、处理器以及运行时等都可能对操作的执行顺序进行一些意想不到的调整。
* 内置锁可以用于确保某个线程以一种可预测的方式来查看另一个线程的执行结果。
* 加锁的含义不仅仅局限于互斥行为，还包括内存可见性。为了确保所有线程都能看到共享变量的最新值，所有执行读操作或者写操作的线程都必须在同一个锁上同步。
* volatile 变量是一种稍弱的同步机制。
* 当把变量声明为 volatile 类型后，编译器与运行时都会注意到这个变量是共享的，因此不会将该变量上的操作与其他内存操作一起重排序。volatile 变量不会被缓存在寄存器或者对其他处理器不可见的地方，因此在读取 volatile 类型的变量时总会返回最新写入的值。
* 访问 volatile 变量时不会执行加锁操作，因此也就不会使执行线程阻塞，因此 volatile 变量是一种比 synchronized 关键字更轻量级的同步机制。
* 仅当 volatile 变量能简化代码的实现以及对同步策略的验证时，才应该使用它们。
* 加锁机制既可以确保可见性又可以确保原子性，而 volatile 变量只能确保可见性。
* 当且仅当满足以下所有条件时，才应该使用 volatile 变量
  * 对变量的写入操作不依赖变量的当前值，或者你能确保只有单个线程更新变量的值。
  * 该变量不会与其他状态变量一起纳入不变性条件中。
  * 在访问变量时不需要加锁。

### 3.2 发布与逸出

### 3.3 线程封闭

* 栈封闭：只能通过局部变量才能访问对象。
* ThreadLocal 类能使线程中的某个值与保存值得对象关联起来。ThreadLoacl 提供了 get 与 set 等访问接口或方法，这些方法为每个使用该变量的线程都存有一份独立的副本，因此 get 宗师返回由当前执行线程在调用 set 时设置的最新值。
* ThreadLocal 对象通常用于防止对可变的单实例变量或全局变量进行共享。

### 3.4 不变性

* 不可变对象一定是线程安全的。
* 满足以下条件的对象才是可变的：
  * 对象创建以后其状态就不能修改。
  * 对象的所有域都是 final 类型。
  * 对象是正确创建的（在对象的创建期间，this 引用没有逸出）。

### 3.5 安全发布

* 在没有额外的同步的情况下，任何线程都可以安全地使用被安全发布的事实不可变对象。
* 对于可变对象，不仅在发布对象时需要使用同步，并且在每次对象访问时同样需要使用同步来确保后续修改操作的可见性。
* 在并发程序中使用和共享对象时，可以使用一些实用的策略，包括：
* 线程封闭。线程封闭的对象只能由一个线程拥有，对象被封闭在该线程中，并且只能由这个线程修改。
* 只读共享。在没有额外同步的情况下，共享的只读对象可以由多个线程并发访问。
* 线程安全共享。线程安全的对象在其内部实现同步，因此多个线程可以通过对象的共有接口来进行访问而不需要进一步的同步。
* 保护对象。被保护的对象只能通过持有特定的锁来访问。保护对象包括封装在其他线程安全对象中的对象，以及已发布的并且由某个特定锁保护的对象。

## 第 4 章 对象的组合

### 4.1 设计线程安全的类

* 设计线程安全类的过程中，需要包含三个基本要素：
  * 找出构成对象状态的所有变量。
  * 找出约束状态变量的不变性条件。
  * 建立对象状态的并发访问管理策略。
* 类的不变性条件与后验条件约束力在对象上有哪些状态和状态转换是有效的。

### 4.2 实例封闭

* 将数据封装在对象内部，可以将数据的访问限制在对象的方法上，从而更易确保线程在访问数据时总能持有正确的锁。
* 封闭机制更易于构造线程安全的类，因为当封闭类的状态时，在分析类的线程安全性时就无需检查整个程序。

### 4.3 线程安全性的委托

* 如果一个类是由多个独立且线程安全的状态变量组成，并且在所有的操作中都不包含无效状态转换，那么可以将线程安全性委托给底层的状态变量。

* 如果一个状态变量是线程安全的，并且没有任何不变性条件来约束它的值，在变量的操作上也不存在任何不允许的状态转换，那么就可以安全地发布这个变量。

### 4.4 在现有的线程安全类中添加功能

### 4.5 将同步策略文档化

## 第 5 章 基础构建模块

### 5.1 同步容器类

* 包括 Vector 和 Hashtable。
* 实现线程安全的方式是：将它们的状态封装起来，并对每个公有方法都进行同步，使得每次只有一个线程能访问容器的状态。
* 同步容器类的问题
  * 迭代，如果有其他线程并发修改容器，会抛出 ConcurrentModificationException
  * 跳转
  * 条件运算
* 解决方法
  * 在客户端额外加锁来保护复合操作。

### 5.2 并发容器

* 包括 ConcurrentHashMap、CopyOnWriteArrayList、CopyOnWriteArraySet。
* ConcurrentHashMap 用于替代同步 HashMap。
* ConcurrentHashMap 的实现机制是分段锁。在这种机制中，任意数量的读线程可以并发访问 Map，一定数量的写线程可以并发修改 Map。
* ConcurrentHashMap 在并发访问环境下实现了更高的吞吐量，而在单线程环境中只损失非常小的性能。
* ConcurrentHashMap 不同于同步容器，不需要再迭代过程中对容器加锁。
* CopyOnWriteArrayList 用于替代同步 List。CopyOnWrite 意味着写入时复制，即在每次修改时，都会创建并重新发布一个新的容器副本，从而实现可变性。写入时复制容器的迭代器保留一个指向底层基础数组的引用，这个数组当前位于迭代器的起始位置，由于它不会被修改，因此在对齐进行同步时只需确保数组内容的可见性。

### 5.3 BlockingQueue

* BlockingQueue 提供了可阻塞的 put 和 take 方法，以及支持定时的 offer 和 poll 方法。如果队列满了，那么 put 方法将阻塞直到有空间可用；如果列队为空，那么 take 方法将阻塞到有元素可用。队列可以是有界的或无界的，无界队列永远不会填满，所以无界队列的 put 方法永远不会阻塞。
* BlockingQueue 支持生产者-消费者模式。
* BlockingQueue 的实现：LinkedBlockingQueue 和 ArrayBlockingQueue 是 FIFO 队列。PriorityBlockingQueue 是一个按优先级排序的队列。

* 5.3.1 示例：桌面搜索
* 5.3.2 串行线程封闭
* 5.3.3 双端队列与工作密取

### 5.4 阻塞方法与中断方法

### 5.5 同步工具类

* 5.5.1 闭锁
* 5.5.2 FutureTask
* 5.5.3 信号量
* 5.5.4 栅栏

### 5.6 构建高效且可伸缩的结果缓存

# 第二部分 结构化并发应用程序

## 第 6 章 任务执行

### 6.1 在线程中执行任务

* 6.1.1 串行地执行任务
* 6.1.2 显式地为任务创建线程
* 6.1.3 无限制创建线程的不足

### 6.2 Executor 框架

* 6.2.1 示例：基于 Executor 的 Web 服务器
* 6.2.2 执行策略
* 6.2.3 线程池
* 6.2.4 Executor 的生命周期
* 6.2.5 延迟任务与周期任务

### 6.3 找出可利用的并行性

* 6.3.1 示例：串行的页面渲染器
* 6.3.2 携带结果的任务 Callable 与 Future
* 6.3.3 示例：使用 Future 实现页面渲染器
* 6.3.4 在异构任务并行化中存在的局限
* 6.3.5 CompletionService:Executor 与 BlockingQueue
* 6.3.6 示例：使用 CompletionService 实现页面渲染器
* 6.3.7 为任务设置时限
* 6.3.8 示例：旅行预定门户网站

## 第 7 章 取消与关闭

### 7.1 任务取消

* 7.1.1 中断
* 7.1.2 中断策略
* 7.1.3 响应中断
* 7.1.4 示例：计时运行
* 7.1.5 通过 Future 来实现取消
* 7.1.6 处理不可中断的阻塞
* 7.1.7 采用 newTaskFor 来封装非标准的取消

### 7.2 停止基于线程的服务

* 7.2.1 示例：日志服务
* 7.2.2 关闭 ExecutorService
* 7.2.3 “毒丸”对象
* 7.2.4 示例：只执行一次的服务
* 7.2.5 shutdownNow 的局限性

### 7.3 处理非正常的线程终止

### 7.4 JVM 关闭

* 7.4.1 关闭钩子
* 7.4.2 守护线程
* 7.4.3 终结器

## 第 8 章 线程池的使用

### 8.1 在任务与执行策略之间的隐性耦合

* 8.1.1 线程饥饿死锁
* 8.1.2 运行时间较长的任务

### 8.2 设置线程池的大小

### 8.3 配置 ThreadPoolExecutor

* 8.3.1 线程的创建与销毁
* 8.3.2 管理队列任务
* 8.3.3 饱和策略
* 8.3.4 线程工厂
* 8.3.5 在调用构造函数后再定制 ThreadPoolExecutor

### 8.4 扩展 ThreadPoolExecutor

### 8.5 递归算法的并行化

## 第 9 章 图形用户界面应用程序

Swing 什么鬼？略

# 第三部分 活跃性、性能与测试

## 第 10 章 避免活跃性危险

### 10.1 死锁

* 10.1.1 锁顺序死锁
* 10.1.2 动态的锁顺序死锁
* 10.1.3 在协作对象之间发生的死锁
* 10.1.4 开放调用
* 10.1.5 资源死锁

### 10.2 死锁的避免与诊断

* 10.2.1 支持定时的锁
* 10.2.2 通过线程转储信息来分析死锁

### 10.3 其他活跃性危险

* 10.3.1 饥饿
* 10.3.2 糟糕的响应性
* 10.3.3 活锁

## 第 11 章 性能与可伸缩性

### 11.1 对性能的思考

* 11.1.1 性能与可伸缩性
* 11.1.2 评估各种性能权衡因素

### 11.2 Amdahl 定律

* 11.2.1 示例：在各种框架中隐藏的串行部分
* 11.2.2 Amdahl 定律的应用

### 11.3 线程引入的开销

* 11.3.1 上下文切换
* 11.3.2 内存同步
* 11.3.3 阻塞

### 11.4 减少锁的竞争

* 11.4.1 缩小锁的范围（“快进快出”）
* 11.4.2 减小锁的粒度
* 11.4.3 锁分段
* 11.4.4 避免热点域
* 11.4.5 一些替代独占锁的方法
* 11.4.6 监测 CPU 的利用率
* 11.4.7 向对象池说“不”

### 11.5 示例：比较 Map 的性能

### 11.6 减少上下文切换的开销

## 第 12 章 并发程序的测试

### 12.1 正确性测试

* 12.1.1 基本的单元测试
* 12.1.2 对阻塞操作的测试
* 12.1.3 安全性测试
* 12.1.4 资源管理的测试
* 12.1.5 使用回调
* 12.1.6 产生更多的交替操作

### 12.2 性能测试

* 12.2.1 在 PutTakeTest 中增加计时功能
* 12.2.2 多种算法的比较
* 12.2.3 响应性衡量

### 12.3 避免性能测试的陷阱

* 12.3.1 垃圾回收
* 12.3.2 动态编译
* 12.3.3 对代码路径的不真实采样
* 12.3.4 不真实的竞争程度
* 12.3.5 无用代码的消除

### 12.4 其他的测试方法

* 12.4.1 代码审查
* 12.4.2 静态分析工具
* 12.4.3 面向方面的测试技术
* 12.4.4 分析与监测工具

# 第四部分 高级主题

## 第 13 章 显式锁

### 13.1 Lock 与 ReentrantLock

* 13.1.1 轮询锁与定时锁
* 13.1.2 可中断的锁获取操作
* 13.1.3 非块结构的加锁

### 13.2 性能考虑因素

### 13.3 公平性

### 13.4 在 synchronized 和 ReentrantLock 之间进行选择

### 13.5 读-写锁

## 第 14 章 构建自定义的同步工具

### 14.1 状态依赖性的管理

* 14.1.1 示例：将前提条件的失败传递给调用者
* 14.1.2 示例：通过轮询与休眠来实现简单的阻塞
* 14.1.3 条件队列

### 14.2 使用条件队列

* 14.2.1 条件谓词
* 14.2.2 过早唤醒
* 14.2.3 丢失的信号
* 14.2.4 通知
* 14.2.5 示例：阀门类
* 14.2.6 子类的安全问题
* 14.2.7 封装条件队列
* 14.2.8 入口协议与出口协议

### 14.3 显式的 Condition 对象

### 14.4 Synchronizer 剖析

### 14.5 AbstractQueuedSynchronizer

### 14.6 java.util.concurrent 同步器类中的 AQS

* 14.6.1 ReentrantLock
* 14.6.2 Semaphore 与 CountDownLatch
* 14.6.3 FutureTask
* 14.6.4 ReentrantReadWriteLock

## 第 15 章 原子变量与非阻塞同步机制

### 15.1 锁的劣势

### 15.2 硬件对并发的支持

* 15.2.1 比较并交换
* 15.2.2 非阻塞的计数器
* 15.2.3 JVM 对 CAS 的支持

### 15.3 原子变量类

* 15.3.1 原子变量是一种“更好的 volatile”
* 15.3.2 性能比较：锁与原子变量

### 15.4 非阻塞算法

* 15.4.1 非阻塞的栈
* 15.4.2 非阻塞的链表
* 15.4.3 原子的域更新器
* 15.4.4 ABA 问题

## 第 16 章 Java 内存模型

### 16.1 什么是内存模型，为什么需要它

* 16.1.1 平台的内存模型
* 16.1.2 重排序
* 16.1.3 Java 内存模型简介
* 16.1.4 借助同步

### 16.2 发布

* 16.2.1 不安全的发布
* 16.2.2 安全的发布
* 16.2.3 安全初始化模式
* 16.2.4 双重检查加锁

### 16.3 初始化过程中的安全性
