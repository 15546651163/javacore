# 从操作系统角度聊聊并发的发展

世上本无路，走的人多了也就有了路。我想，任何一种技术同样不是平白无故的出现，必然是为了解决某类问题而产生。

所以，我们不妨来谈谈并发编程的发展，这非常有助于加深我们对并发编程的理解。这就是知其然，也要知其所以然。

## 串行

早期的计算机系统是基于单个处理器（即 CPU）的顺序处理机器。何为顺序处理？简言之，凡事都得排队，一个一个处理。

而早起的软件程序也都是串行程序。即程序运行时只能执行

## 并发 vs 并行

> **并发**是指两个或多个事件在同一时间间隔发生。
>

> **并行**是指两个或者多个事件在同一时刻发生。
>

并发和并行的区别

> 打个比喻（来源于 [并发与并行的区别？ - 龚昱阳 Dozer的回答 - 知乎](https://www.zhihu.com/question/33515481/answer/58849148)）：
>
> 你吃饭吃到一半，电话来了，你一直到吃完了以后才去接，这就说明你不支持并发也不支持并行。
> 你吃饭吃到一半，电话来了，你停了下来接了电话，接完后继续吃饭，这说明你支持并发。
> 你吃饭吃到一半，电话来了，你一边打电话一边吃饭，这说明你支持并行。
>
> 并发的关键是你有处理多个任务的能力，不一定要同时。
> 并行的关键是你有同时处理多个任务的能力。

![img](https://pic4.zhimg.com/50/v2-674f0d37fca4fac1bd2df28a2b78e633_hd.jpg)

## 进程 vs 线程

> **进程**是操作系统能够进行资源分配的最小单位。可以理解为正在运行的程序。
>

> **线程**是操作系统能够进行运算调度的最小单位。
>

进程和线程的区别

线程是进程的子集。

不同的进程使用不同的内存空间；所有的线程共享一片相同的内存空间。

![“process thread”的图片搜索结果](https://i4mk.files.wordpress.com/2013/03/processes-vs-threads.jpg)

## 竞态条件和临界区

在同一程序中运行多个线程本身不会导致问题，问题在于多个线程访问了相同的资源。如，同一内存区（变量，数组，或对象）、系统（数据库，web services等）或文件。实际上，这些问题只有在一或多个线程向这些资源做了写操作时才有可能发生，只要资源没有发生变化,多个线程读取相同的资源就是安全的。

多线程同时执行下面的代码可能会出错：

```java
public class Counter {
    protected long count = 0;
    public void add(long value){
        this.count = this.count + value;  
    }
}
```

想象下线程A和B同时执行同一个Counter对象的add()方法，我们无法知道操作系统何时会在两个线程之间切换。JVM并不是将这段代码视为单条指令来执行的，而是按照下面的顺序：

1. 从内存获取 this.count 的值放到寄存器
2. 将寄存器中的值增加value
3. 将寄存器中的值写回内存

观察线程A和B交错执行会发生什么：

this.count = 0;
A:	读取 this.count 到一个寄存器 (0)
B:	读取 this.count 到一个寄存器 (0)
B: 	将寄存器的值加2
B:	回写寄存器值(2)到内存. this.count 现在等于 2
A:	将寄存器的值加3
A:	回写寄存器值(3)到内存. this.count 现在等于 3

两个线程分别加了2和3到count变量上，两个线程执行结束后count变量的值应该等于5。然而由于两个线程是交叉执行的，两个线程从内存中读出的初始值都是0。然后各自加了2和3，并分别写回内存。最终的值并不是期望的5，而是最后写回内存的那个线程的值，上面例子中最后写回内存的是线程A，但实际中也可能是线程B。如果没有采用合适的同步机制，线程间的交叉执行情况就无法预料。

### 竞态条件 & 临界区定义

当两个线程竞争同一资源时，如果对资源的访问顺序敏感，就称存在**竞态条件**。

导致竞态条件发生的代码区称作**临界区**。上例中add()方法就是一个临界区,它会产生竞态条件。在临界区中使用适当的同步就可以避免竞态条件。

## 线程安全与共享资源

允许被多个线程同时执行的代码称作线程安全的代码。线程安全的代码不包含竞态条件。当多个线程同时更新共享资源时会引发竞态条件。因此，了解Java线程执行时共享了什么资源很重要。

