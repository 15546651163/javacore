---
title: 线程基础
date: 2018/05/22
categories:
- javase
tags:
- javase
- concurrent
---

# 线程基础

<!-- TOC depthFrom:2 depthTo:3 -->

* [线程生命周期](#线程生命周期)
* [创建线程](#创建线程)
    * [继承 Thread 类](#继承-thread-类)
    * [实现 Runnable 接口](#实现-runnable-接口)
    * [通过 Callable 接口和 Future 接口](#通过-callable-接口和-future-接口)
    * [三种创建线程方式对比](#三种创建线程方式对比)
* [Thread 中的重要方法](#thread-中的重要方法)
    * [设置/获取线程名称](#设置获取线程名称)
    * [判断线程是否启动](#判断线程是否启动)
    * [中断线程](#中断线程)
    * [守护线程](#守护线程)
    * [设置/获取线程优先级](#设置获取线程优先级)
    * [线程的强制执行](#线程的强制执行)
    * [线程的休眠](#线程的休眠)
    * [线程的礼让](#线程的礼让)
    * [线程的终止](#线程的终止)
* [Object 中的并发方法](#object-中的并发方法)
    * [wait/notify/notifyAll](#waitnotifynotifyall)
* [FAQ](#faq)
    * [start() 和 run() 有什么区别？可以直接调用 Thread 类的 run() 方法么？](#start-和-run-有什么区别可以直接调用-thread-类的-run-方法么)
    * [sleep()、yield()、join() 方法有什么区别？为什么 sleep()和 yield()方法是静态的？](#sleepyieldjoin-方法有什么区别为什么-sleep和-yield方法是静态的)
    * [为什么 sleep() 和 yield() 方法是静态的](#为什么-sleep-和-yield-方法是静态的)
    * [Java 的线程优先级如何控制？高优先级的 Java 线程一定先执行吗？](#java-的线程优先级如何控制高优先级的-java-线程一定先执行吗)
    * [什么是守护线程？为什么要用守护线程？如何创建守护线程？](#什么是守护线程为什么要用守护线程如何创建守护线程)
    * [为什么线程通信的方法 wait(), notify()和 notifyAll()被定义在 Object 类里？](#为什么线程通信的方法-wait-notify和-notifyall被定义在-object-类里)
    * [为什么 wait(), notify()和 notifyAll()必须在同步方法或者同步块中被调用？](#为什么-wait-notify和-notifyall必须在同步方法或者同步块中被调用)
* [资料](#资料)

<!-- /TOC -->

## 线程生命周期

* 开始(New)：如果创建 Thread 类的实例，但在调用 start() 方法之前，线程处于新状态。
* 可运行(Runnable)：线程对象创建后，其他线程(比如 main 线程）调用了该对象的 start()方法。此状态意味着，线程已经准备好了，一旦被线程调度器分配了 CPU 时间片，就可以运行线程。
* 运行(Running)：可运行状态(Runnable)的线程获得了 cpu 时间片（timeslice），执行程序代码。
* 定时等待(Timed waiting)：定时等待是在指定等待时间内等待的线程状态。调用以下方法，线程会进入定时等待状态：
  * Thread.sleep(sleeptime)
  * Object.wait(timeout)
  * Thread.join(timeout)
  * LockSupport.parkNanos(timeout)
  * LockSupport.parkUntil(timeout)
* 等待(Waiting)：等待状态。处于等待状态的线程是由于执行了 3 个方法中的任意方法：
  * Object.wait()
  * Thread.join()
  * LockSupport.park()
* 阻塞(Blocked)：阻塞状态。线程阻塞的线程状态等待监视器锁定。处于阻塞状态的线程正在等待监视器锁定，以便在调用 Object.wait 之后输入同步块/方法或重新输入同步块/方法。
* 终止(Terminated)：线程 run()、main() 方法执行结束，或者因异常退出了 run()方法，则该线程结束生命周期。死亡的线程不可再次复生。

线程状态切换如下图所示：

<p align="center">
  <img src="https://raw.githubusercontent.com/dunwu/javase-notes/master/images/concurrent/thread-states.png" alt="thread-states">
</p>

## 创建线程

创建线程主要有三种方式

* 继承 Thread 类
* 实现 Runnable 接口
* 通过 Callable 接口和 Future 接口

### 继承 Thread 类

* 定义 Thread 类的子类，并重写该类的 run 方法，该 run 方法的方法体就代表了线程要完成的任务。因此把 run()方法称为执行体。
* 创建 Thread 子类的实例，即创建了线程对象。
* 调用线程对象的 start()方法来启动该线程。

```java
public class ThreadDemo02 {

    public static void main(String[] args) {
        Thread02 mt1 = new Thread02("线程A "); // 实例化对象
        Thread02 mt2 = new Thread02("线程B "); // 实例化对象
        mt1.start(); // 调用线程主体
        mt2.start(); // 调用线程主体
    }

    static class Thread02 extends Thread {

        private int ticket = 5;

        Thread02(String name) {
            super(name);
        }

        @Override
        public void run() {
            for (int i = 0; i < 100; i++) {
                if (this.ticket > 0) {
                    System.out.println(this.getName() + " 卖票：ticket = " + ticket--);
                }
            }
        }
    }
}
```

### 实现 Runnable 接口

* 定义 Runnable 接口的实现类，并重写该接口的 run()方法，该 run()方法的方法体同样是该线程的线程执行体。
* 创建 Runnable 实现类的实例，并依此实例作为 Thread 的 target 来创建 Thread 对象，该 Thread 对象才是真正的线程对象。
* 调用线程对象的 start()方法来启动该线程。

```java
public class RunnableDemo {

    public static void main(String[] args) {
        MyThread t = new MyThread("Runnable 线程"); // 实例化对象
        new Thread(t).run(); // 调用线程主体
        new Thread(t).run(); // 调用线程主体
        new Thread(t).run(); // 调用线程主体
    }

    static class MyThread implements Runnable {

        private int ticket = 5;
        private String name;

        MyThread(String name) {
            this.name = name;
        }

        @Override
        public void run() {
            for (int i = 0; i < 100; i++) {
                if (this.ticket > 0) {
                    System.out.println(this.name + " 卖票：ticket = " + ticket--);
                }
            }
        }
    }
}
```

### 通过 Callable 接口和 Future 接口

* 创建 Callable 接口的实现类，并实现 call()方法，该 call()方法将作为线程执行体，并且有返回值。
* 创建 Callable 实现类的实例，使用 FutureTask 类来包装 Callable 对象，该 FutureTask 对象封装了该 Callable 对象的 call()方法的返回值。
* 使用 FutureTask 对象作为 Thread 对象的 target 创建并启动新线程。
* 调用 FutureTask 对象的 get()方法来获得子线程执行结束后的返回值

```java
public class CallableAndFutureDemo {

    public static void main(String[] args) {
        Callable<Integer> callable = () -> new Random().nextInt(100);
        FutureTask<Integer> future = new FutureTask<>(callable);
        new Thread(future).start();
        try {
            Thread.sleep(1000);// 可能做一些事情
            System.out.println(future.get());
        } catch (InterruptedException | ExecutionException e) {
            e.printStackTrace();
        }
    }
}
```

### 三种创建线程方式对比

* 实现 Runnable 接口优于继承 Thread 类，因为实现接口更便于扩展；
* 实现 Runnable 接口的线程没有返回值；而使用 Callable Future 方式可以让线程有返回值。

## Thread 中的重要方法

* `run` - 线程的执行实体。
* `start` - 线程的启动方法。
* `setName`、`getName` - 可以通过 setName()、 getName() 来设置、获取线程名称。
* `setPriority`、`getPriority` - 在 Java 中，所有线程在运行前都会保持在就绪状态，那么此时，哪个线程优先级高，哪个线程就有可能被先执行。可以通过 setPriority、getPriority 来设置、获取线程优先级。
* `setDaemon`、`isDaemon` - 可以使用 setDaemon() 方法设置线程为守护线程；可以使用 isDaemon() 方法判断线程是否为守护线程。
* `isAlive` - 可以通过 isAlive 来判断线程是否启动。
* `interrupt` - 当一个线程运行时，另一个线程可以直接通过 interrupt() 方法中断其运行状态。
* `join` - 使用 join() 方法让一个线程强制运行，线程强制运行期间，其他线程无法运行，必须等待此线程完成之后才可以继续执行。
* `Thread.sleep` - 使用 Thread.sleep() 方法即可实现休眠。
* `Thread.yield` - 可以使用 Thread.yield() 方法将一个线程的操作暂时让给其他线程执行。

### 设置/获取线程名称

在 Thread 类中可以通过 `setName()`、 `getName()` 来设置、获取线程名称。

```java
public class ThreadNameDemo {

    public static void main(String[] args) {
        MyThread mt = new MyThread(); // 实例化Runnable子类对象
        new Thread(mt).start(); // 系统自动设置线程名称
        new Thread(mt, "线程-A").start(); // 手工设置线程名称
        Thread t = new Thread(mt); // 手工设置线程名称
        t.setName("线程-B");
        t.start();
    }

    static class MyThread implements Runnable {

        @Override
        public void run() {
            for (int i = 0; i < 3; i++) {
                System.out.println(Thread.currentThread().getName() + "运行，i = " + i); // 取得当前线程的名字
            }
        }
    }
}
```

### 判断线程是否启动

在 Thread 类中可以通过 `isAlive()` 来判断线程是否启动。

```java
public class ThreadAliveDemo {

    public static void main(String[] args) {
        MyThread mt = new MyThread(); // 实例化Runnable子类对象
        Thread t = new Thread(mt, "线程"); // 实例化Thread对象
        System.out.println("线程开始执行之前 --> " + t.isAlive()); // 判断是否启动
        t.start(); // 启动线程
        System.out.println("线程开始执行之后 --> " + t.isAlive()); // 判断是否启动
        for (int i = 0; i < 3; i++) {
            System.out.println(" main运行 --> " + i);
        }
        // 以下的输出结果不确定
        System.out.println("代码执行之后 --> " + t.isAlive()); // 判断是否启动

    }

    static class MyThread implements Runnable {

        @Override
        public void run() {
            for (int i = 0; i < 3; i++) {
                System.out.println(Thread.currentThread().getName() + "运行，i = " + i);
            }
        }
    }
}
```

### 中断线程

当一个线程运行时，另一个线程可以直接通过 `interrupt()` 方法中断其运行状态。

```java
public class ThreadInterruptDemo {

    public static void main(String[] args) {
        MyThread mt = new MyThread(); // 实例化Runnable子类对象
        Thread t = new Thread(mt, "线程"); // 实例化Thread对象
        t.start(); // 启动线程
        try {
            Thread.sleep(2000); // 线程休眠2秒
        } catch (InterruptedException e) {
            System.out.println("3、休眠被终止");
        }
        t.interrupt(); // 中断线程执行
    }

    static class MyThread implements Runnable {

        @Override
        public void run() {
            System.out.println("1、进入run()方法");
            try {
                Thread.sleep(10000); // 线程休眠10秒
                System.out.println("2、已经完成了休眠");
            } catch (InterruptedException e) {
                System.out.println("3、休眠被终止");
                return; // 返回调用处
            }
            System.out.println("4、run()方法正常结束");
        }
    }
}
```

### 守护线程

在 Java 程序中，只要前台有一个线程在运行，则整个 Java 进程就不会消失，所以此时可以设置一个守护线程，这样即使 Java 进程结束了，此守护线程依然会继续执行。可以使用 `setDaemon()` 方法设置线程为守护线程；可以使用 `isDaemon()` 方法判断线程是否为守护线程。

```java
public class ThreadDaemonDemo {

    public static void main(String[] args) {
        Thread t = new Thread(new MyThread(), "线程");
        t.setDaemon(true); // 此线程在后台运行
        System.out.println("线程 t 是否是守护进程：" + t.isDaemon());
        t.start(); // 启动线程
    }

    static class MyThread implements Runnable {

        @Override
        public void run() {
            while (true) {
                System.out.println(Thread.currentThread().getName() + "在运行。");
            }
        }
    }
}
```

### 设置/获取线程优先级

在 Java 中，所有线程在运行前都会保持在就绪状态，那么此时，哪个线程优先级高，哪个线程就有可能被先执行。

```java
public class ThreadPriorityDemo {

    public static void main(String[] args) {
        System.out.println("主方法的优先级：" + Thread.currentThread().getPriority());
        System.out.println("MAX_PRIORITY = " + Thread.MAX_PRIORITY);
        System.out.println("NORM_PRIORITY = " + Thread.NORM_PRIORITY);
        System.out.println("MIN_PRIORITY = " + Thread.MIN_PRIORITY);

        Thread t1 = new Thread(new MyThread(), "线程A"); // 实例化线程对象
        Thread t2 = new Thread(new MyThread(), "线程B"); // 实例化线程对象
        Thread t3 = new Thread(new MyThread(), "线程C"); // 实例化线程对象
        t1.setPriority(Thread.MIN_PRIORITY); // 优先级最低
        t2.setPriority(Thread.MAX_PRIORITY); // 优先级最低
        t3.setPriority(Thread.NORM_PRIORITY); // 优先级最低
        t1.start(); // 启动线程
        t2.start(); // 启动线程
        t3.start(); // 启动线程
    }

    static class MyThread implements Runnable {

        @Override
        public void run() {
            for (int i = 0; i < 5; i++) {
                try {
                    Thread.sleep(500); // 线程休眠
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                // 取得当前线程的名字
                String out =
                    Thread.currentThread().getName() + "，优先级：" + Thread.currentThread().getPriority() + "，运行：i = " + i;
                System.out.println(out);
            }
        }
    }
}
```

### 线程的强制执行

在线程操作中，可以使用 `join()` 方法让一个线程强制运行，线程强制运行期间，其他线程无法运行，必须等待此线程完成之后才可以继续执行。

```java
public class ThreadJoinDemo {

    public static void main(String[] args) {
        MyThread mt = new MyThread(); // 实例化Runnable子类对象
        Thread t = new Thread(mt, "mythread"); // 实例化Thread对象
        t.start(); // 启动线程
        for (int i = 0; i < 50; i++) {
            if (i > 10) {
                try {
                    t.join(); // 线程强制运行
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            System.out.println("Main 线程运行 --> " + i);
        }
    }

    static class MyThread implements Runnable {

        @Override
        public void run() {
            for (int i = 0; i < 50; i++) {
                System.out.println(Thread.currentThread().getName() + " 运行，i = " + i); // 取得当前线程的名字
            }
        }
    }
}
```

### 线程的休眠

直接使用 `Thread.sleep()` 方法即可实现休眠。

```java
public class ThreadSleepDemo {

    public static void main(String[] args) {
        new Thread(new MyThread("线程A", 1000)).start();
        new Thread(new MyThread("线程A", 2000)).start();
        new Thread(new MyThread("线程A", 3000)).start();
    }

    static class MyThread implements Runnable {

        private String name;
        private int time;

        private MyThread(String name, int time) {
            this.name = name; // 设置线程名称
            this.time = time; // 设置休眠时间
        }

        @Override
        public void run() {
            try {
                Thread.sleep(this.time); // 休眠指定的时间
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(this.name + "线程，休眠" + this.time + "毫秒。");
        }
    }
}
```

### 线程的礼让

在线程操作中，可以使用 `Thread.yield()` 方法将一个线程的操作暂时让给其他线程执行。

```java
public class ThreadYieldDemo {

    public static void main(String[] args) {
        MyThread t = new MyThread();
        new Thread(t, "线程A").start();
        new Thread(t, "线程B").start();
    }

    static class MyThread implements Runnable {

        @Override
        public void run() {
            for (int i = 0; i < 5; i++) {
                try {
                    Thread.sleep(1000);
                } catch (Exception e) {
                    e.printStackTrace();
                }
                System.out.println(Thread.currentThread().getName() + "运行，i = " + i);
                if (i == 2) {
                    System.out.print("线程礼让：");
                    Thread.yield();
                }
            }
        }
    }
}
```

### 线程的终止

Thread 中的 stop 方法有缺陷，已废弃。

```java
public class ThreadStopDemo02 {

    public static void main(String[] args) {
        MyThread my = new MyThread();
        new Thread(my, "线程").start();
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        my.stop(); // 修改标志位，停止运行
    }

    static class MyThread implements Runnable {

        private volatile boolean flag = true; // 定义标志位

        @Override
        public void run() {
            int i = 0;
            while (this.flag) {
                System.out.println(Thread.currentThread().getName() + "运行，i = " + (i++));
            }
            System.out.println(Thread.currentThread().getName() + "线程停止");
        }

        void stop() {
            this.flag = false; // 修改标志位
        }
    }
}
```

## Object 中的并发方法

* `wait` - 线程自动释放其占有的对象锁，并等待 notify。
* `notify` - 唤醒一个正在 wait 当前对象锁的线程，并让它拿到对象锁。
* `notifyAll` - 唤醒所有正在 wait 前对象锁的线程。

### wait/notify/notifyAll

生产者、消费者示例：

```java
public class ThreadWaitNotifyDemo02 {

    private static final int QUEUE_SIZE = 10;
    private static final PriorityQueue<Integer> queue = new PriorityQueue<>(QUEUE_SIZE);

    public static void main(String[] args) {
        new Producer("生产者A").start();
        new Producer("生产者B").start();
        new Consumer("消费者A").start();
        new Consumer("消费者B").start();
    }

    static class Consumer extends Thread {

        Consumer(String name) {
            super(name);
        }

        @Override
        public void run() {
            while (true) {
                synchronized (queue) {
                    while (queue.size() == 0) {
                        try {
                            System.out.println("队列空，等待数据");
                            queue.wait();
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                            queue.notifyAll();
                        }
                    }
                    queue.poll(); // 每次移走队首元素
                    queue.notifyAll();
                    try {
                        Thread.sleep(500);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    System.out.println(Thread.currentThread().getName() + " 从队列取走一个元素，队列当前有：" + queue.size() + "个元素");
                }
            }
        }
    }

    static class Producer extends Thread {

        Producer(String name) {
            super(name);
        }

        @Override
        public void run() {
            while (true) {
                synchronized (queue) {
                    while (queue.size() == QUEUE_SIZE) {
                        try {
                            System.out.println("队列满，等待有空余空间");
                            queue.wait();
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                            queue.notifyAll();
                        }
                    }
                    queue.offer(1); // 每次插入一个元素
                    queue.notifyAll();
                    try {
                        Thread.sleep(500);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    System.out.println(Thread.currentThread().getName() + " 向队列取中插入一个元素，队列当前有：" + queue.size() + "个元素");
                }
            }
        }
    }
}
```

## FAQ

### start() 和 run() 有什么区别？可以直接调用 Thread 类的 run() 方法么？

run() 方法是线程的执行体。

start() 方法会启动线程，然后 JVM 会让这个线程去执行 run() 方法。

可以直接调用 Thread 类的 run() 方法么？

* 可以。但是如果直接调用 Thread 的 run()方法，它的行为就会和普通的方法一样。
* 为了在新的线程中执行我们的代码，必须使用 Thread.start()方法。

### sleep()、yield()、join() 方法有什么区别？为什么 sleep()和 yield()方法是静态的？

* yield()
  * yield() 方法可以让当前正在执行的线程暂停，但它不会阻塞该线程，它只是将该线程从 Running 状态转入 Runnable 状态。
  * 当某个线程调用了 yield() 方法暂停之后，只有优先级与当前线程相同，或者优先级比当前线程更高的处于就绪状态的线程才会获得执行的机会。
* sleep()
  * sleep() 方法需要指定等待的时间，它可以让当前正在执行的线程在指定的时间内暂停执行，进入 Blocked 状态。
  * 该方法既可以让其他同优先级或者高优先级的线程得到执行的机会，也可以让低优先级的线程得到执行机会。
  * 但是， sleep() 方法不会释放“锁标志”，也就是说如果有 synchronized 同步块，其他线程仍然不能访问共享数据。
* join()
  * join() 方法会使当前线程转入 Blocked 状态，等待调用 join() 方法的线程结束后才能继续执行。

> 参考阅读：[Java 线程中 yield 与 join 方法的区别](http://www.importnew.com/14958.html)
> 参考阅读：[sleep()，wait()，yield()和 join()方法的区别](https://blog.csdn.net/xiangwanpeng/article/details/54972952)

### 为什么 sleep() 和 yield() 方法是静态的

* Thread 类的 sleep() 和 yield() 方法将处理 Running 状态的线程。所以在其他处于非 Running 状态的线程上执行这两个方法是没有意义的。这就是为什么这些方法是静态的。它们可以在当前正在执行的线程中工作，并避免程序员错误的认为可以在其他非运行线程调用这些方法。

### Java 的线程优先级如何控制？高优先级的 Java 线程一定先执行吗？

* Java 中的线程优先级如何控制
  * Java 中的线程优先级的范围是 [1,10]，一般来说，高优先级的线程在运行时会具有优先权。可以通过 `thread.setPriority(Thread.MAX_PRIORITY)` 的方式设置，默认优先级为 5。
* 高优先级的 Java 线程一定先执行吗
  * 即使设置了线程的优先级，也**无法保证高优先级的线程一定先执行**。
  * 原因：这是因为线程优先级依赖于操作系统的支持，然而，不同的操作系统支持的线程优先级并不相同，不能很好的和 Java 中线程优先级一一对应。
  * 结论：Java 线程优先级控制并不可靠。

### 什么是守护线程？为什么要用守护线程？如何创建守护线程？

* 什么是守护线程
  * 守护线程（Daemon Thread）是在后台执行并且不会阻止 JVM 终止的线程。
  * 与守护线程（Daemon Thread）相反的，叫用户线程（User Thread），也就是非守护线程。
* 为什么要用守护线程
  * 守护线程的优先级比较低，用于为系统中的其它对象和线程提供服务。典型的应用就是垃圾回收器。
* 如何创建守护线程
  * 使用 thread.setDaemon(true) 可以设置 thread 线程为守护线程。
  * 注意点：
    * 正在运行的用户线程无法设置为守护线程，所以 thread.setDaemon(true) 必须在 thread.start() 之前设置，否则会抛出 llegalThreadStateException 异常；
    * 一个守护线程创建的子线程依然是守护线程。
    * 不要认为所有的应用都可以分配给 Daemon 来进行服务，比如读写操作或者计算逻辑。

> 参考阅读：[Java 中守护线程的总结](https://blog.csdn.net/shimiso/article/details/8964414)

### 为什么线程通信的方法 wait(), notify()和 notifyAll()被定义在 Object 类里？

Java 的每个对象中都有一个锁(monitor，也可以成为监视器) 并且 wait()，notify()等方法用于等待对象的锁或者通知其他线程对象的监视器可用。在 Java 的线程中并没有可供任何对象使用的锁和同步器。这就是为什么这些方法是 Object 类的一部分，这样 Java 的每一个类都有用于线程间通信的基本方法

### 为什么 wait(), notify()和 notifyAll()必须在同步方法或者同步块中被调用？

当一个线程需要调用对象的 wait()方法的时候，这个线程必须拥有该对象的锁，接着它就会释放这个对象锁并进入等待状态直到其他线程调用这个对象上的 notify()方法。同样的，当一个线程需要调用对象的 notify()方法时，它会释放这个对象的锁，以便其他在等待的线程就可以得到这个对象锁。由于所有的这些方法都需要线程持有对象的锁，这样就只能通过同步来实现，所以他们只能在同步方法或者同步块中被调用。

> 参考阅读：[Java 并发编程：volatile 关键字解析](http://www.cnblogs.com/dolphin0520/p/3920373.html)

## 资料

* [Java 并发编程实战](https://item.jd.com/10922250.html)
* [Java 并发编程的艺术](https://item.jd.com/11740734.html)
* https://stackoverflow.com/questions/27406200/visualvm-thread-states
* https://docs.oracle.com/javase/1.5.0/docs/api/java/lang/Thread.State.html
* https://www.journaldev.com/1037/java-thread-wait-notify-and-notifyall-example
* http://www.importnew.com/14958.html
* https://blog.csdn.net/xiangwanpeng/article/details/54972952
* https://blog.csdn.net/shimiso/article/details/8964414
