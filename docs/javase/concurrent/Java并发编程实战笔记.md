# Java 并发编程实战笔记

<!-- TOC depthFrom:2 depthTo:3 -->

- [第 1 章 简介](#第-1-章-简介)
  - [1.1 并发简史](#11-并发简史)
  - [1.2 线程的优势](#12-线程的优势)
  - [1.3 线程带来的风险](#13-线程带来的风险)
  - [1.4 线程无处不在](#14-线程无处不在)
- [第 2 章 线程安全性](#第-2-章-线程安全性)
  - [2.1 什么是线程安全性](#21-什么是线程安全性)
  - [2.2 原子性](#22-原子性)
  - [2.3 加锁机制](#23-加锁机制)
  - [2.4 用锁来保护状态](#24-用锁来保护状态)
  - [2.5 活跃性与性能](#25-活跃性与性能)
- [第 3 章 对象的共享](#第-3-章-对象的共享)
  - [3.1 可见性](#31-可见性)
  - [3.2 发布与逸出](#32-发布与逸出)
  - [3.3 线程封闭](#33-线程封闭)
  - [3.4 不变性](#34-不变性)
  - [3.5 安全发布](#35-安全发布)
- [第 4 章 对象的组合](#第-4-章-对象的组合)
  - [4.1 设计线程安全的类](#41-设计线程安全的类)
  - [4.2 实例封闭](#42-实例封闭)
  - [4.3 线程安全性的委托](#43-线程安全性的委托)
  - [4.4 在现有的线程安全类中添加功能](#44-在现有的线程安全类中添加功能)
  - [4.5 将同步策略文档化](#45-将同步策略文档化)
- [第 5 章 基础构建模块](#第-5-章-基础构建模块)
  - [5.1 同步容器类](#51-同步容器类)
  - [5.2 并发容器](#52-并发容器)
  - [5.3 阻塞队列和生产者-消费者模式](#53-阻塞队列和生产者-消费者模式)
  - [5.4 阻塞方法与中断方法](#54-阻塞方法与中断方法)
  - [5.5 同步工具类](#55-同步工具类)
  - [5.6 构建高效且可伸缩的结果缓存](#56-构建高效且可伸缩的结果缓存)
- [第 6 章 任务执行](#第-6-章-任务执行)
  - [6.1 在线程中执行任务](#61-在线程中执行任务)
  - [6.2 Executor 框架](#62-executor-框架)
  - [6.3 找出可利用的并行性](#63-找出可利用的并行性)
- [第 7 章 取消与关闭](#第-7-章-取消与关闭)
  - [7.1 任务取消](#71-任务取消)
  - [7.2 停止基于线程的服务](#72-停止基于线程的服务)
  - [7.3 处理非正常的线程终止](#73-处理非正常的线程终止)
  - [7.4 JVM 关闭](#74-jvm-关闭)
- [第 8 章 线程池的使用](#第-8-章-线程池的使用)
  - [8.1 在任务与执行策略之间的隐性耦合](#81-在任务与执行策略之间的隐性耦合)
  - [8.2 设置线程池的大小](#82-设置线程池的大小)
  - [8.3 配置 ThreadPoolExecutor](#83-配置-threadpoolexecutor)
  - [8.4 扩展 ThreadPoolExecutor](#84-扩展-threadpoolexecutor)
  - [8.5 递归算法的并行化](#85-递归算法的并行化)
- [第 9 章 图形用户界面应用程序](#第-9-章-图形用户界面应用程序)
- [第 10 章 避免活跃性危险](#第-10-章-避免活跃性危险)
  - [10.1 死锁](#101-死锁)
  - [10.2 死锁的避免与诊断](#102-死锁的避免与诊断)
  - [10.3 其他活跃性危险](#103-其他活跃性危险)
- [第 11 章 性能与可伸缩性](#第-11-章-性能与可伸缩性)
  - [11.1 对性能的思考](#111-对性能的思考)
  - [11.2 Amdahl 定律](#112-amdahl-定律)
  - [11.3 线程引入的开销](#113-线程引入的开销)
  - [11.4 减少锁的竞争](#114-减少锁的竞争)
  - [11.5 示例：比较 Map 的性能](#115-示例比较-map-的性能)
  - [11.6 减少上下文切换的开销](#116-减少上下文切换的开销)
- [第 12 章 并发程序的测试](#第-12-章-并发程序的测试)
  - [12.1 正确性测试](#121-正确性测试)
  - [12.2 性能测试](#122-性能测试)
  - [12.3 避免性能测试的陷阱](#123-避免性能测试的陷阱)
  - [12.4 其他的测试方法](#124-其他的测试方法)
- [第 13 章 显式锁](#第-13-章-显式锁)
  - [13.1 Lock 与 ReentrantLock](#131-lock-与-reentrantlock)
  - [13.2 性能考虑因素](#132-性能考虑因素)
  - [13.3 公平性](#133-公平性)
  - [13.4 在 synchronized 和 ReentrantLock 之间进行选择](#134-在-synchronized-和-reentrantlock-之间进行选择)
  - [13.5 读-写锁](#135-读-写锁)
- [第 14 章 构建自定义的同步工具](#第-14-章-构建自定义的同步工具)
  - [14.1 状态依赖性的管理](#141-状态依赖性的管理)
  - [14.2 使用条件队列](#142-使用条件队列)
  - [14.3 显式的 Condition 对象](#143-显式的-condition-对象)
  - [14.4 Synchronizer 剖析](#144-synchronizer-剖析)
  - [14.5 AbstractQueuedSynchronizer](#145-abstractqueuedsynchronizer)
  - [14.6 java.util.concurrent 同步器类中的 AQS](#146-javautilconcurrent-同步器类中的-aqs)
- [第 15 章 原子变量与非阻塞同步机制](#第-15-章-原子变量与非阻塞同步机制)
  - [15.1 锁的劣势](#151-锁的劣势)
  - [15.2 硬件对并发的支持](#152-硬件对并发的支持)
  - [15.3 原子变量类](#153-原子变量类)
  - [15.4 非阻塞算法](#154-非阻塞算法)
- [第 16 章 Java 内存模型](#第-16-章-java-内存模型)
  - [16.1 什么是内存模型，为什么需要它](#161-什么是内存模型为什么需要它)
  - [16.2 发布](#162-发布)
  - [16.3 初始化过程中的安全性](#163-初始化过程中的安全性)

<!-- /TOC -->

## 第 1 章 简介

### 1.1 并发简史

### 1.2 线程的优势

* 1.2.1 发挥多处理器的强大能力
* 1.2.2 建模的简单性
* 1.2.3 异步事件的简化处理
* 1.2.4 响应更灵敏的用户界面

### 1.3 线程带来的风险

* 1.3.1 安全性问题
* 1.3.2 活跃性问题
* 1.3.3 性能问题

### 1.4 线程无处不在

# 第一部分 基础知识

## 第 2 章 线程安全性

### 2.1 什么是线程安全性

### 2.2 原子性

* 2.2.1 竞态条件
* 2.2.2 示例：延迟初始化中的竞态条件
* 2.2.3 复合操作

### 2.3 加锁机制

* 2.3.1 内置锁
* 2.3.2 重入

### 2.4 用锁来保护状态

### 2.5 活跃性与性能

## 第 3 章 对象的共享

### 3.1 可见性

* 3.1.1 失效数据
* 3.1.2 非原子的 64 位操作
* 3.1.3 加锁与可见性
* 3.1.4 Volatile 变量

### 3.2 发布与逸出

### 3.3 线程封闭

* 3.3.1 Ad-hoc 线程封闭
* 3.3.2 栈封闭
* 3.3.3 ThreadLocal 类

### 3.4 不变性

* 3.4.1 Final 域
* 3.4.2 示例：使用 Volatile 类型来发布不可变对象

### 3.5 安全发布

* 3.5.1 不正确的发布：正确的对象被破坏
* 3.5.2 不可变对象与初始化安全性
* 3.5.3 安全发布的常用模式
* 3.5.4 事实不可变对象
* 3.5.5 可变对象
* 3.5.6 安全地共享对象

## 第 4 章 对象的组合

### 4.1 设计线程安全的类

* 4.1.1 收集同步需求
* 4.1.2 依赖状态的操作
* 4.1.3 状态的所有权

### 4.2 实例封闭

* 4.2.1 Java 监视器模式
* 4.2.2 示例：车辆追踪

### 4.3 线程安全性的委托

* 4.3.1 示例：基于委托的车辆追踪器
* 4.3.2 独立的状态变量
* 4.3.3 当委托失效时
* 4.3.4 发布底层的状态变量
* 4.3.5 示例：发布状态的车辆追踪器

### 4.4 在现有的线程安全类中添加功能

* 4.4.1 客户端加锁机制
* 4.4.2 组合

### 4.5 将同步策略文档化

## 第 5 章 基础构建模块

### 5.1 同步容器类

* 5.1.1 同步容器类的问题
* 5.1.2 迭代器与 Concurrent-ModificationException
* 5.1.3 隐藏迭代器

### 5.2 并发容器

* 5.2.1 ConcurrentHashMap
* 5.2.2 额外的原子 Map 操作
* 5.2.3 CopyOnWriteArrayList

### 5.3 阻塞队列和生产者-消费者模式

* 5.3.1 示例：桌面搜索
* 5.3.2 串行线程封闭
* 5.3.3 双端队列与工作密取

### 5.4 阻塞方法与中断方法

### 5.5 同步工具类

* 5.5.1 闭锁
* 5.5.2 FutureTask
* 5.5.3 信号量
* 5.5.4 栅栏

### 5.6 构建高效且可伸缩的结果缓存

# 第二部分 结构化并发应用程序

## 第 6 章 任务执行

### 6.1 在线程中执行任务

* 6.1.1 串行地执行任务
* 6.1.2 显式地为任务创建线程
* 6.1.3 无限制创建线程的不足

### 6.2 Executor 框架

* 6.2.1 示例：基于 Executor 的 Web 服务器
* 6.2.2 执行策略
* 6.2.3 线程池
* 6.2.4 Executor 的生命周期
* 6.2.5 延迟任务与周期任务

### 6.3 找出可利用的并行性

* 6.3.1 示例：串行的页面渲染器
* 6.3.2 携带结果的任务 Callable 与 Future
* 6.3.3 示例：使用 Future 实现页面渲染器
* 6.3.4 在异构任务并行化中存在的局限
* 6.3.5 CompletionService:Executor 与 BlockingQueue
* 6.3.6 示例：使用 CompletionService 实现页面渲染器
* 6.3.7 为任务设置时限
* 6.3.8 示例：旅行预定门户网站

## 第 7 章 取消与关闭

### 7.1 任务取消

* 7.1.1 中断
* 7.1.2 中断策略
* 7.1.3 响应中断
* 7.1.4 示例：计时运行
* 7.1.5 通过 Future 来实现取消
* 7.1.6 处理不可中断的阻塞
* 7.1.7 采用 newTaskFor 来封装非标准的取消

### 7.2 停止基于线程的服务

* 7.2.1 示例：日志服务
* 7.2.2 关闭 ExecutorService
* 7.2.3 “毒丸”对象
* 7.2.4 示例：只执行一次的服务
* 7.2.5 shutdownNow 的局限性

### 7.3 处理非正常的线程终止

### 7.4 JVM 关闭

* 7.4.1 关闭钩子
* 7.4.2 守护线程
* 7.4.3 终结器

## 第 8 章 线程池的使用

### 8.1 在任务与执行策略之间的隐性耦合

* 8.1.1 线程饥饿死锁
* 8.1.2 运行时间较长的任务

### 8.2 设置线程池的大小

### 8.3 配置 ThreadPoolExecutor

* 8.3.1 线程的创建与销毁
* 8.3.2 管理队列任务
* 8.3.3 饱和策略
* 8.3.4 线程工厂
* 8.3.5 在调用构造函数后再定制 ThreadPoolExecutor

### 8.4 扩展 ThreadPoolExecutor

### 8.5 递归算法的并行化

## 第 9 章 图形用户界面应用程序

Swing 什么鬼？略

# 第三部分 活跃性、性能与测试

## 第 10 章 避免活跃性危险

### 10.1 死锁

* 10.1.1 锁顺序死锁
* 10.1.2 动态的锁顺序死锁
* 10.1.3 在协作对象之间发生的死锁
* 10.1.4 开放调用
* 10.1.5 资源死锁

### 10.2 死锁的避免与诊断

* 10.2.1 支持定时的锁
* 10.2.2 通过线程转储信息来分析死锁

### 10.3 其他活跃性危险

* 10.3.1 饥饿
* 10.3.2 糟糕的响应性
* 10.3.3 活锁

## 第 11 章 性能与可伸缩性

### 11.1 对性能的思考

* 11.1.1 性能与可伸缩性
* 11.1.2 评估各种性能权衡因素

### 11.2 Amdahl 定律

* 11.2.1 示例：在各种框架中隐藏的串行部分
* 11.2.2 Amdahl 定律的应用

### 11.3 线程引入的开销

* 11.3.1 上下文切换
* 11.3.2 内存同步
* 11.3.3 阻塞

### 11.4 减少锁的竞争

* 11.4.1 缩小锁的范围（“快进快出”）
* 11.4.2 减小锁的粒度
* 11.4.3 锁分段
* 11.4.4 避免热点域
* 11.4.5 一些替代独占锁的方法
* 11.4.6 监测 CPU 的利用率
* 11.4.7 向对象池说“不”

### 11.5 示例：比较 Map 的性能

### 11.6 减少上下文切换的开销

## 第 12 章 并发程序的测试

### 12.1 正确性测试

* 12.1.1 基本的单元测试
* 12.1.2 对阻塞操作的测试
* 12.1.3 安全性测试
* 12.1.4 资源管理的测试
* 12.1.5 使用回调
* 12.1.6 产生更多的交替操作

### 12.2 性能测试

* 12.2.1 在 PutTakeTest 中增加计时功能
* 12.2.2 多种算法的比较
* 12.2.3 响应性衡量

### 12.3 避免性能测试的陷阱

* 12.3.1 垃圾回收
* 12.3.2 动态编译
* 12.3.3 对代码路径的不真实采样
* 12.3.4 不真实的竞争程度
* 12.3.5 无用代码的消除

### 12.4 其他的测试方法

* 12.4.1 代码审查
* 12.4.2 静态分析工具
* 12.4.3 面向方面的测试技术
* 12.4.4 分析与监测工具

# 第四部分 高级主题

## 第 13 章 显式锁

### 13.1 Lock 与 ReentrantLock

* 13.1.1 轮询锁与定时锁
* 13.1.2 可中断的锁获取操作
* 13.1.3 非块结构的加锁

### 13.2 性能考虑因素

### 13.3 公平性

### 13.4 在 synchronized 和 ReentrantLock 之间进行选择

### 13.5 读-写锁

## 第 14 章 构建自定义的同步工具

### 14.1 状态依赖性的管理

* 14.1.1 示例：将前提条件的失败传递给调用者
* 14.1.2 示例：通过轮询与休眠来实现简单的阻塞
* 14.1.3 条件队列

### 14.2 使用条件队列

* 14.2.1 条件谓词
* 14.2.2 过早唤醒
* 14.2.3 丢失的信号
* 14.2.4 通知
* 14.2.5 示例：阀门类
* 14.2.6 子类的安全问题
* 14.2.7 封装条件队列
* 14.2.8 入口协议与出口协议

### 14.3 显式的 Condition 对象

### 14.4 Synchronizer 剖析

### 14.5 AbstractQueuedSynchronizer

### 14.6 java.util.concurrent 同步器类中的 AQS

* 14.6.1 ReentrantLock
* 14.6.2 Semaphore 与 CountDownLatch
* 14.6.3 FutureTask
* 14.6.4 ReentrantReadWriteLock

## 第 15 章 原子变量与非阻塞同步机制

### 15.1 锁的劣势

### 15.2 硬件对并发的支持

* 15.2.1 比较并交换
* 15.2.2 非阻塞的计数器
* 15.2.3 JVM 对 CAS 的支持

### 15.3 原子变量类

* 15.3.1 原子变量是一种“更好的 volatile”
* 15.3.2 性能比较：锁与原子变量

### 15.4 非阻塞算法

* 15.4.1 非阻塞的栈
* 15.4.2 非阻塞的链表
* 15.4.3 原子的域更新器
* 15.4.4 ABA 问题

## 第 16 章 Java 内存模型

### 16.1 什么是内存模型，为什么需要它

* 16.1.1 平台的内存模型
* 16.1.2 重排序
* 16.1.3 Java 内存模型简介
* 16.1.4 借助同步

### 16.2 发布

* 16.2.1 不安全的发布
* 16.2.2 安全的发布
* 16.2.3 安全初始化模式
* 16.2.4 双重检查加锁

### 16.3 初始化过程中的安全性
